[{"categories":["Software Engineering"],"content":"Layered Architecture 分层架构 Each layer represents a level of abstraction or specificity Provides higher-level services to the layer above it Relies on lower-level services from the layer below it ","date":"2023-04-18","objectID":"/architecture/:1:0","tags":["Developments"],"title":"Architecture","uri":"/architecture/"},{"categories":["Software Engineering"],"content":"Pure Form: Only Adjacent Layers Communicate. 只有相同的层之间可以通信。 Pros: Abstraction: One layer builds on another. Portability: Lower-level layers can be easily replaced. Cons: Performance: Communicating through layers. Limited functionality: No access to specialized features in lower layers. ","date":"2023-04-18","objectID":"/architecture/:1:1","tags":["Developments"],"title":"Architecture","uri":"/architecture/"},{"categories":["Software Engineering"],"content":"Relaxed Form: Cross-Layer Optimazation 在分层架构中，有时为了优化性能或功能，需要允许非相邻层之间进行通信。(ceph: bluestore) Dependency on Layer Below (not above) 原则上是这样的，但是在relaxed form中反转一下也不是不行 eg: Callback Interface ","date":"2023-04-18","objectID":"/architecture/:1:2","tags":["Developments"],"title":"Architecture","uri":"/architecture/"},{"categories":["Software Engineering"],"content":"Exception Handing Strategies 异常处理策略 Exceptions can be handled in layer where they occurred or passed up May need to transform exceptions into layers understood by upper layers 异常可以在发生它们的层级中处理或者向上传递。有时需要将异常转换为上层能够理解的形式。 Best to handle in layer they occur Usually most information needed is available there Upper layers may be confronted with error they don’t understand Passing exceptions up increases coupling 增加耦合性 ","date":"2023-04-18","objectID":"/architecture/:1:3","tags":["Developments"],"title":"Architecture","uri":"/architecture/"},{"categories":["Software Engineering"],"content":"Consequences Pros: Understanding system by abstraction levels Insulation(隔离) from changes in lower levels Different implementations of a level can be interchanged Cons: Potential performance problems Not all systems easily structured in layers 不是适合所有系统 ","date":"2023-04-18","objectID":"/architecture/:1:4","tags":["Developments"],"title":"Architecture","uri":"/architecture/"},{"categories":["Software Engineering"],"content":"What are examples of layered systems? ISO OSI (which is me的噩梦) FTP TCP/IP (me通信网68分) ","date":"2023-04-18","objectID":"/architecture/:1:5","tags":["Developments"],"title":"Architecture","uri":"/architecture/"},{"categories":["Software Engineering"],"content":"Two Special Cases Of Layered Architectures Interpreters Interpreters Execute programs in a computer language Ojen represent a kind of layer in a system Subject to layered architecture consequences Virtual Machines A software implementation of a machine A special kind of interpreter (previous slide) May be implemented as just-in time compiler Hypervisors Tiered architectures Layered architecture used enterprise systems They evolved from monolithic to multi-tier ","date":"2023-04-18","objectID":"/architecture/:1:6","tags":["Developments"],"title":"Architecture","uri":"/architecture/"},{"categories":["Software Engineering"],"content":"Call-And-Return Architectures ","date":"2023-04-18","objectID":"/architecture/:2:0","tags":["Developments"],"title":"Architecture","uri":"/architecture/"},{"categories":["Software Engineering"],"content":"Main Program and Subroutines Hierarchical decomposition into subroutines 将大型计算机程序分解为小的子程序 Imperative, mutable state 势在必行的可变的状态？ Classic style since 60s aka “Structured programming” 结构化编程 Effective for smaller systems 对小系统有效 ","date":"2023-04-18","objectID":"/architecture/:2:1","tags":["Developments"],"title":"Architecture","uri":"/architecture/"},{"categories":["Software Engineering"],"content":"Verification \u0026 Validation Verification The process of evaluating a system/component to determine whether the products of a given development activity satisfy the conditions imposed at the start of that activity. 确定它是否符合早期定义的需求、标准和规范。 Validation The process of evaluating a system/component during or at the end of the development process to determine whether the software does what the user really requires. ","date":"2023-04-17","objectID":"/testing/:1:0","tags":["Developments"],"title":"Verification \u0026 Validation and Testing","uri":"/testing/"},{"categories":["Software Engineering"],"content":"Dynamic and static verification Dynamic V \u0026 V Concerned with exercising and observing product behavior. “Dynamic V\u0026V” 是指动态验证和确认，是软件开发和测试中的一种技术，其关注点是对产品行为的测试和观察。 Static verification Concerned with analysis of the static system representation to discover problems (i.e., without executing the program) 静态验证是指对静态系统表示进行分析，以发现问题的过程（即在不执行程序的情况下）。 ","date":"2023-04-17","objectID":"/testing/:1:1","tags":["Developments"],"title":"Verification \u0026 Validation and Testing","uri":"/testing/"},{"categories":["Software Engineering"],"content":"Testing ","date":"2023-04-17","objectID":"/testing/:2:0","tags":["Developments"],"title":"Verification \u0026 Validation and Testing","uri":"/testing/"},{"categories":["Software Engineering"],"content":"Testing stages Unit testing（单元测试） Testing of individual components Integration testing（集成测试，测试组件之间的连接） Testing to expose problems arising from the combination of components System testing（系统测试） Testing the complete system prior to delivery Acceptance testing（可能就是咱常说的AC） Testing by users to check that the system satisfies requirements. Sometimes called alpha testing ","date":"2023-04-17","objectID":"/testing/:2:1","tags":["Developments"],"title":"Verification \u0026 Validation and Testing","uri":"/testing/"},{"categories":["Software Engineering"],"content":"Types of testing Defect testing 缺陷测试 Tests designed to discover system defects. A successful defect test is one which reveals the presence of defects in a system. Operational profile 操作特征模型，便于性能测试，负载测试等 Statistical tests designed to reflect the frequency of user inputs. Used for reliability estimation and performance testing. ","date":"2023-04-17","objectID":"/testing/:2:2","tags":["Developments"],"title":"Verification \u0026 Validation and Testing","uri":"/testing/"},{"categories":["Software Engineering"],"content":"Some Terminology Failure A failure is said to occur whenever the external behavior does not conform to system spec. 指系统在实际运行中无法按照规范和要求正常工作的情况。 Error An error is a state of the system which, in the absence of any corrective action, could lead to a failure. Fault An adjudged cause of an error. 故障的原因 ","date":"2023-04-17","objectID":"/testing/:2:3","tags":["Developments"],"title":"Verification \u0026 Validation and Testing","uri":"/testing/"},{"categories":["Software Engineering"],"content":"Testing and debugging Testing is concerned with confirming the presence of errors. Debugging is concerned with locating and repairing these errors Debugging Activities ","date":"2023-04-17","objectID":"/testing/:2:4","tags":["Developments"],"title":"Verification \u0026 Validation and Testing","uri":"/testing/"},{"categories":["Software Engineering"],"content":"Testing Activities ","date":"2023-04-17","objectID":"/testing/:2:5","tags":["Developments"],"title":"Verification \u0026 Validation and Testing","uri":"/testing/"},{"categories":["Software Engineering"],"content":"Testing Strategy Black-box Testing Approach to testing where the program is considered as a ‘black-box’ The program test cases are based on the system specification. Test case是基于系统说明书 Test planning can begin early in the software process.可以在早期开始 Possible test design strategy 一种可能的设计策略 Equivalence partitioning 等价划分是一种测试设计策略，它将软件系统的输入数据划分为具有相似行为的组或等价类。这种方法的目标是减少测试系统所需的测试用例数量，同时确保覆盖所有重要的情景。 White-box testing Derivation of test cases according to program structure. Knowledge of the program is used to identify additional test cases. 根据程序结构推导测试用例。这种策略利用对程序内部结构和代码逻辑的了解，来识别额外的测试用例。 Possible test design strategy Equivalence partitioning Code coverage Code Coverage Statement coverage 语句覆盖 Select a test set T such that by executing P for each case in T, each statement of P is executed at least once. 测试集合T中的测试用例可以使P中的每个statement执行至少一次 Branch/Edge coverage 分支覆盖 Select a set T such that, by executing P for each member in T, each edge of P’s control-flow graph is traversed at least once. Condition coverage 条件覆盖 All possible values of the constituents of compound conditions are exercised at least once. Path coverage 路径覆盖 Select a test set T such that, by executing P for each member of T, all paths leading from the initial node to the final node of P’s control-flow graph are traversed. ","date":"2023-04-17","objectID":"/testing/:2:6","tags":["Developments"],"title":"Verification \u0026 Validation and Testing","uri":"/testing/"},{"categories":["Software Engineering"],"content":"A systematic approach to eliciting, organizing, and documenting the requirement of the system, and a process that establishes and maintains agreement between the customer and the project team on the changing requirements of the system. What does requirement mean? the things that the product must do to achieve its purpose functional requirements What the system does the qualities the product must have quality (aka non-functional) requirements How well the system does ","date":"2023-04-17","objectID":"/requirement/:0:0","tags":["Developments"],"title":"Requirement Engineering","uri":"/requirement/"},{"categories":["Software Engineering"],"content":"Functional vs. quality requirements Functional requirements describe what a system or product must do to achieve its intended purpose. Quality requirements, on the other hand, describe the non-functional characteristics or attributes that a system or product must possess to meet user expectations and achieve its objectives. Example: One of the functional requirements of the control software for a PBX is to automatically detect line faults. Detection of line faults is a functional requirement. Now let us say that a fault must be detected within 20 minutes. This is a performance requirement — a quality one ","date":"2023-04-17","objectID":"/requirement/:1:0","tags":["Developments"],"title":"Requirement Engineering","uri":"/requirement/"},{"categories":["Software Engineering"],"content":"Necessary properties of requirements Unambiguous the meaning should be clear Consistent one requirement must not contradict another Complete E.g.: “The process is terminated if the wrong PIN has been entered more than a certain number of times.” (What is that number?) • Verifiable (possible to test) a requirement that cannot be tested is not a requirement E.g.: “The system should work in real-time mode.” (What is “real time” here?) ","date":"2023-04-17","objectID":"/requirement/:2:0","tags":["Developments"],"title":"Requirement Engineering","uri":"/requirement/"},{"categories":["Software Engineering"],"content":"A desirable property of requirements Free of implementation bias E.g., “The system shall accept a password when data is accessed.” ——— This has a requirement to use password. 显然就是说不太行 “The system shall ensure that the data can be accessed only by authorized users.” ——— This gives you an opportunity to search for alternatives Feasible 可行性 It should be realizable with reasonable effort ","date":"2023-04-17","objectID":"/requirement/:3:0","tags":["Developments"],"title":"Requirement Engineering","uri":"/requirement/"},{"categories":["Software Engineering"],"content":"Class Diagrams A dass diagram describes the types of objects in the System and the various kinds of static relationships that exist among them. 类图描述了系统中对象的类型以及它们之间存在的各种静态关系。 ","date":"2023-04-16","objectID":"/uml/:0:0","tags":["Developments"],"title":"UML——Class Diagrams","uri":"/uml/"},{"categories":["Software Engineering"],"content":"Attributes 特性 The attribute notation describes a property as a line of text within the class box itself. The full form of an attribute is: visibility name: type multiplicity = default {property-string} 访问控制符（visibility） + 属性名称（name） + 冒号（:）+ 属性类型（type）+ 多重性（multiplicity）+ 等号（=）+ 默认值（default）+ 花括号（{}）+ 属性字符串（property-string） This visibility marker indicates whether the attribute is public (+) or private (-); The name of the attribute - how the class refers to the attribute - roughly corresponds to the name of a field in a programming language. 属性的名称（attribute name）指的是类如何引用该属性，大致对应于编程语言中字段（field）的名称。 The type of the attribute indicates a restriction an what kind of object（string, int, bool, etc.） may be placed in the attribute. You can think of this as the type of a field in a programming language. The default value is the value for a newly created object if the attribute isn’t specified during creation. The {property-string} allows you to indicate additional properties for the attribute. In the example, I used {readOnly} to indicate that clients may not modify the property. If this is missing, you can usually assume that the attribute is modifiable. An example of this is: name: String [1] = \"Untitled\" {readOnly} Only the name is necessary. ","date":"2023-04-16","objectID":"/uml/:1:0","tags":["Developments"],"title":"UML——Class Diagrams","uri":"/uml/"},{"categories":["Software Engineering"],"content":"Associations 关系 An association is a solid line between two classes, directed from the source class to the target class. ","date":"2023-04-16","objectID":"/uml/:2:0","tags":["Developments"],"title":"UML——Class Diagrams","uri":"/uml/"},{"categories":["Software Engineering"],"content":"Multiplicity 多重性 The multiplicity of a property is an indication of how many objects may fill the property. The most common multiplicities you will see are: 1 (An order must have exactly one customer.) 0..1 (A corporate customer may or may not have a single sales rep.) * (A customer need not place an Order and there is no upper limit to the number of Orders a Customer may place-zero or more orders.) More generally, multiplicities are defined with a lower bound and an upper bound. The lower bound may beany positive number or zero; the upper is any positive number or * (for unlimited). If the lower and upper bounds are the same, you can use one number; hence, 1 is equivalent to 1..1.Because it’s a common case, * is short for 0..*. ","date":"2023-04-16","objectID":"/uml/:3:0","tags":["Developments"],"title":"UML——Class Diagrams","uri":"/uml/"},{"categories":["Software Engineering"],"content":"Generalization 继承？ ","date":"2023-04-16","objectID":"/uml/:4:0","tags":["Developments"],"title":"UML——Class Diagrams","uri":"/uml/"},{"categories":["Software Engineering"],"content":"Aggregation and Composition 聚合和组合 聚合是一种关系，其中一个对象包含对另一个对象的引用，但被包含的对象可以独立于容器对象而存在。换句话说，被包含的对象并不是容器对象所拥有的。聚合通常用一个指向被包含类的菱形表示，例如汽车和其轮子之间的关系。 组合是一种关系，其中一个对象拥有另一个对象，并且所拥有的对象的生命周期与拥有对象的生命周期相同。换句话说，被拥有的对象不能在没有拥有它的对象的情况下存在。组合通常用一个填充的菱形表示，例如汽车和其引擎之间的关系。 ","date":"2023-04-16","objectID":"/uml/:5:0","tags":["Developments"],"title":"UML——Class Diagrams","uri":"/uml/"},{"categories":["Software Engineering"],"content":"Interfaces and Abstract Classes 接口和抽象类 An abstract class is a class that cannot be directly instantiated. The most common way to indicate an abstract dass or operation in the UML is to italicize the name, you can also use the label : {abstract} . An interface is a class that has no implementation ; that is, all its features are abstract. You mark an interface with the key-word \u003c\u003cinterface\u003e\u003e. Object Diagrams An object diagram is a snapshot of the objects in a System at a point in time. Because it Shows instances rather than classes, an object diagram is often called an instance diagram. ","date":"2023-04-16","objectID":"/uml/:6:0","tags":["Developments"],"title":"UML——Class Diagrams","uri":"/uml/"},{"categories":["Software Engineering"],"content":"Design Patterns 设计模式 我第一次学习设计模式是在北京实习的时候突然给我派了一个攒一整个测试系统的工作，我开始研究哪一种设计模式是最合适的。虽然最后做出来一坨大便，但是确实是我第一次为一个系统从0开始独自写了千行以上的代码，虽然是一坨大便，但是个人成长最大的一次经历，之后 involve in 更大的项目之后都没有那一坨大便让人印象深刻。 ","date":"2023-04-15","objectID":"/first_post/:0:0","tags":["Developments"],"title":"软件工程的复习——设计模式","uri":"/first_post/"},{"categories":["Software Engineering"],"content":"What is a design pattern? (Overview) A design pattern is a solution to a re-occurring design problem. 在软件开发中，经常会遇到一些相似的问题，例如如何创建对象、如何处理对象之间的关系、如何处理对象之间的通信等等。这些问题在不同的项目中可能会多次出现。设计模式是针对这些重复出现的问题所提供的解决方案。它们是被普遍接受的、经过验证的、可重用的和可扩展的设计方案，可以用来解决特定类型的问题。 Design patterns follow a general format consisting of: Design problem, including the relevant context Design solution Design consequences, including positive andnegative impacts of the solution on system qualities. ","date":"2023-04-15","objectID":"/first_post/:1:0","tags":["Developments"],"title":"软件工程的复习——设计模式","uri":"/first_post/"},{"categories":["Software Engineering"],"content":"Design Solution The design solution typically includes a structural part, consisting of elements with dedicated roles and relationships among them; this aspect is usually represented using a class diagram. 结构性方面通常由一些具有专门角色和彼此之间关系的元素组成，这些元素可以使用类图（class diagram）进行表示。类图用于表示软件系统中类（class）、接口（interface）、对象（object）之间的关系，包括继承（inheritance）、关联（association）、聚合（aggregation）和组合（composition）等。通过类图，我们可以清晰地看到软件系统中各个元素之间的关系和依赖。 Some patterns also involve behavioral aspects, that is, interactions among the elements of the structure; this aspect is typically represented using sequence diagrams, but statecharts and activity diagrams can also be used. 行为性方面则通常涉及到元素之间的交互，这些交互可以使用序列图（sequence diagram）、状态图（statechart）和活动图（activity diagram）等进行表示。序列图用于表示软件系统中对象之间的交互顺序，状态图用于表示软件系统中对象的状态和状态之间的转换，活动图用于表示软件系统中的活动和活动之间的流程。 ","date":"2023-04-15","objectID":"/first_post/:1:1","tags":["Developments"],"title":"软件工程的复习——设计模式","uri":"/first_post/"},{"categories":["Software Engineering"],"content":"Design Consequences The design consequences are positive impacts and negative impacts on system qualities (maintainability, complexity, performance, etc.). Some of the impacts may be conditional on the specific implementation variant of the design pattern. 设计模式（design pattern）有一个重要特点，即设计模式需要经过实践的检验才能被认可为有效的设计解决方案。 为了避免设计模式过于专业化，一个设计解决方案只有在被至少用于三个不同的系统中，也就是需要应对反复出现的设计问题，才能被认为是一个设计模式。这意味着设计模式需要经过多次实践的检验，才能被广泛地应用于软件设计和开发中。 ","date":"2023-04-15","objectID":"/first_post/:1:2","tags":["Developments"],"title":"软件工程的复习——设计模式","uri":"/first_post/"},{"categories":["Software Engineering"],"content":"Composite 组合模式 Intent Treat individual objects and multiple, recursively- composed objects uniformly Applicability Objects must be composed recursively No distinction between individual and composed elements Objects in the structure can be treated uniformly 在“Composite”模式中，通常会定义一个抽象的“Component”类，它声明了组合对象和单个对象之间的公共接口。然后定义一个“Composite”类，它表示一个组合对象，可以包含其他组合对象和单个对象。同时还定义一个“Leaf”类，它表示一个单个对象，即不能再包含其他对象的最小单位。这样，“Composite”模式就形成了一个树形结构，其中“Component”类是根节点，而“Composite”类和“Leaf”类是其子节点。 通过这种结构，“Composite”模式可以让客户端在不知道具体对象的情况下，统一地处理组合对象和单个对象。客户端可以通过“Component”类的接口，调用组合对象和单个对象的方法，而无需关心它们之间的具体差异。 当涉及到图形界面时，可以使用“Glyph”类来表示界面元素，例如文本、图形、按钮等。在这种情况下，如果要实现一个包含多个“Glyph”的组合对象，可以使用“Composite”模式。 例如，假设我们要实现一个文本编辑器，它可以显示文本、图像和按钮等元素。我们可以定义一个“Glyph”类作为所有元素的基类，然后定义一个“CompositeGlyph”类，它表示一个组合对象，可以包含多个“Glyph”对象。同时，我们还可以定义一个“SimpleGlyph”类，它表示一个单个的“Glyph”对象。 通过这种结构，“CompositeGlyph”类可以包含多个“SimpleGlyph”对象和其他“CompositeGlyph”对象，从而形成一个树形结构。客户端可以通过“Glyph”类的接口，调用组合对象和单个对象的方法，例如调用“CompositeGlyph”的“Draw”方法，就会递归地调用它包含的所有“Glyph”对象的“Draw”方法，从而将整个界面绘制出来。 使用“Composite”模式可以使代码更加简洁、灵活和易于扩展。例如，如果我们想要添加一个新的元素类型，只需要定义一个新的“Glyph”子类，并将其添加到“CompositeGlyph”对象中即可。这样可以很容易地扩展编辑器的功能，而不需要修改大量的代码。 ","date":"2023-04-15","objectID":"/first_post/:2:0","tags":["Developments"],"title":"软件工程的复习——设计模式","uri":"/first_post/"},{"categories":["Software Engineering"],"content":"Structure Component (Graphic) declares the interface for objects in the composition. implements default behavior for the interface common to all classes, as appropriate. declares an interface for accessing and managing its child components. (optional) defines an interface for accessing a component’s parent in the recursive structure, and implements it if that’s appropriate. Leaf (Rectangle, Line, Text, etc.) represents leaf objects in the composition. A leaf has no children. defines behavior for primitive objects in the composition. Composite (Picture) defines behavior for components having children. stores child components. implements child-related operations in the Component interface. Client manipulates objects in the composition through the Component interface. Consequences Uniformity: treat components the same regardless of complexity Extensibility: new Component subclasses work wherever old ones do Overhead: might need prohibitive numbers of objects Implementation Do Components know their parents? Uniform interface for both leaves and composites? Responsibility for deleting children ","date":"2023-04-15","objectID":"/first_post/:2:1","tags":["Developments"],"title":"软件工程的复习——设计模式","uri":"/first_post/"},{"categories":["Software Engineering"],"content":"Typical Instance Diagram: ","date":"2023-04-15","objectID":"/first_post/:2:2","tags":["Developments"],"title":"软件工程的复习——设计模式","uri":"/first_post/"},{"categories":["Software Engineering"],"content":"Decorator 装饰器模式 Decorator = Transparent wrapper 装饰器模式（Decorator Pattern）的意图和适用性描述。 装饰器模式的主要意图是为对象添加新的职责或功能，而不需要修改原有的对象结构。通过动态地将装饰器对象包装在原有对象的外部，可以在不改变原有对象接口的情况下，为其添加新的行为或功能。这种模式是一种替代继承的方式，避免了深度嵌套和复杂的继承体系。 装饰器模式的适用性包括以下情况： 当使用子类继承方式扩展对象功能时不实际或不可行 当需要动态地为对象添加新的行为或功能，而不希望修改原有对象的接口 当需要为对象添加的行为或功能可以灵活地添加或删除，以满足不同的需求 装饰器模式的优点是允许在运行时动态地为对象添加新的行为或功能，而不需要修改原有的对象代码。它还可以避免类的深度嵌套和复杂的继承体系。但是，装饰器模式会增加代码的复杂性，因为需要创建多个装饰器对象来实现额外的功能。 ","date":"2023-04-15","objectID":"/first_post/:3:0","tags":["Developments"],"title":"软件工程的复习——设计模式","uri":"/first_post/"},{"categories":["Software Engineering"],"content":"Structure Component (VisualComponent) defines the interface for objects that can have responsibilities added to them dynamically. • ConcreteComponent (TextView) defines an object to which additional responsibilities can be attached. Decorator maintains a reference to a Component object and defines an interface that conforms to Component’s interface. ConcreteDecorator (BorderDecorator, ScrollDecorator) adds responsibilities to the component. ","date":"2023-04-15","objectID":"/first_post/:3:1","tags":["Developments"],"title":"软件工程的复习——设计模式","uri":"/first_post/"},{"categories":["Software Engineering"],"content":"Consequences Pros: Responsibilitiescanbeadded/removedatrun-time Avoidssubclassexplosion Recursivenestingallowsmultipleresponsibilities Cons: Interface occlusion Doesnotinheritchildmethods,andthusneedtoimplement forwarding methods Split identity (aka identity crisis, object schizophrenia) Clientsmightbyaccidentpointtothechildratherthanthedecorator ","date":"2023-04-15","objectID":"/first_post/:3:2","tags":["Developments"],"title":"软件工程的复习——设计模式","uri":"/first_post/"},{"categories":["Software Engineering"],"content":"Adaptor ","date":"2023-04-15","objectID":"/first_post/:4:0","tags":["Developments"],"title":"软件工程的复习——设计模式","uri":"/first_post/"},{"categories":["Software Engineering"],"content":"Intent Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces. 使不兼容的接口兼容。 ","date":"2023-04-15","objectID":"/first_post/:4:1","tags":["Developments"],"title":"软件工程的复习——设计模式","uri":"/first_post/"},{"categories":["Software Engineering"],"content":"Structure Target (Shape) defines the domain-specific interface that Client uses. Client (DrawingEditor) collaborates with objects conforming to the Target interface. Adaptee (TextView) defines an existing interface that needs adapting. Adapter (TextShape) adapts the interface of Adaptee to the Target interface. ","date":"2023-04-15","objectID":"/first_post/:4:2","tags":["Developments"],"title":"软件工程的复习——设计模式","uri":"/first_post/"},{"categories":["Software Engineering"],"content":"Adaptor VS Decorator Decorator enhances another object without changing its interface. A decorator is thus more transparent to the application than an adapter is. As a consequence, Decorator supports recursive composition, which isn’t possible with pure adapters. 装饰器模式可以增强一个对象的功能而不改变其接口，因此它对应用程序更加透明，比适配器模式更容易理解。此外，装饰器模式支持递归组合，而适配器模式则不支持。 ","date":"2023-04-15","objectID":"/first_post/:4:3","tags":["Developments"],"title":"软件工程的复习——设计模式","uri":"/first_post/"},{"categories":["Software Engineering"],"content":"Factory Method 参考下这个吧 Factory Method Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses. 工厂方法（Factory Method）是一种创建型设计模式，它定义了一个用于创建对象的接口，但是将具体的对象创建过程延迟到子类中去完成。也就是说，工厂方法模式允许一个类在不直接实例化对象的情况下，将对象的创建任务委托给子类来完成。即，工厂方法模式将对象的创建延迟到子类中，由子类来决定创建哪种具体对象。 Use the Factory Method pattern when a class can’t anticipate the class of objects it must create. 当一个类无法预测它必须创建的对象的类。 a class wants its subclasses to specify the objects it creates. 当一个类希望它的子类指定它创建的对象。 classes delegate responsibility to one of several helper subclasses, and you want to localize the knowledge of which helper subclass is the delegate. 当一个类委托职责给多个辅助子类中的一个，并且需要将关于哪个子类是委托者的知识局部化？？？ ","date":"2023-04-15","objectID":"/first_post/:5:0","tags":["Developments"],"title":"软件工程的复习——设计模式","uri":"/first_post/"},{"categories":["Software Engineering"],"content":"Abstract Factory Abstract Factory Provide an interface for creating families of related or dependent objects without specifying their concrete classes. 抽象工厂模式提供了一个接口，用于创建一组相关或依赖对象，而无需指定其具体类。当一个系统需要独立于其产品如何被创建、组合或表示，并且需要提供一个单一的工厂接口来创建一组相关对象时，可以使用该模式。 ","date":"2023-04-15","objectID":"/first_post/:6:0","tags":["Developments"],"title":"软件工程的复习——设计模式","uri":"/first_post/"},{"categories":["Software Engineering"],"content":"Structure ","date":"2023-04-15","objectID":"/first_post/:6:1","tags":["Developments"],"title":"软件工程的复习——设计模式","uri":"/first_post/"},{"categories":["Software Engineering"],"content":"Abstract Factory and Factory Method Many designs start by using Factory Method (less complicated and more customizable via subclasses) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, but more complicated). Abstract Factory classes are often based on a set of Factory Methods. 抽象工厂基于Factory Method。 The main difference between the Abstract Factory and Factory Method patterns is the level of abstraction. The Factory Method pattern is used to create a single object, while the Abstract Factory pattern is used to create families of related objects. 工厂方法模式用于创建单个对象，而抽象工厂模式用于创建相关对象族群。 ","date":"2023-04-15","objectID":"/first_post/:6:2","tags":["Developments"],"title":"软件工程的复习——设计模式","uri":"/first_post/"},{"categories":["Software Engineering"],"content":"Strategy Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it. 涉及定义一组算法，将每个算法封装成一个单独的类，并使它们可以相互替换。这样可以让算法独立于使用它的clients。 ","date":"2023-04-15","objectID":"/first_post/:7:0","tags":["Developments"],"title":"软件工程的复习——设计模式","uri":"/first_post/"},{"categories":["Software Engineering"],"content":"Structure Strategy (Compositor) declares an interface common to all supported algorithms. Context uses this interface to call the algorithm defined by a ConcreteStrategy. 这是指一个通用的算法接口，它可以支持所有的排版算法。上下文（Context）使用这个接口调用由具体策略（ConcreteStrategy）定义的算法。 ConcreteStrategy (SimpleCompositor, TeXCompositor,ArrayCompositor) implements the algorithm using the Strategy interface. Context (Composition) is configured with a ConcreteStrategy object. 被配置为使用一个具体策略对象。 maintains a reference to a Strategy object. 维护对策略对象的引用。 may define an interface that lets Strategy access its data. 定义一个接口，以便让策略访问其数据。 ","date":"2023-04-15","objectID":"/first_post/:7:1","tags":["Developments"],"title":"软件工程的复习——设计模式","uri":"/first_post/"},{"categories":["Software Engineering"],"content":"Understand how strategy supports dynamic reconfiguration thanks to object composition. 策略模式(Strategy)通过使用对象组合(Composite)，支持在运行时动态地重新配置应用程序的行为。 ","date":"2023-04-15","objectID":"/first_post/:7:2","tags":["Developments"],"title":"软件工程的复习——设计模式","uri":"/first_post/"},{"categories":["Software Engineering"],"content":"Template Method 模版方法 Template Method Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure. 模板方法是一种行为型设计模式，它在一个操作中定义算法的框架，同时将某些步骤推迟到子类中去实现。模板方法允许子类重新定义算法的某些步骤，而不改变算法的整体结构。 ","date":"2023-04-15","objectID":"/first_post/:8:0","tags":["Developments"],"title":"软件工程的复习——设计模式","uri":"/first_post/"},{"categories":["Software Engineering"],"content":"Structure AbstractClass (Application) defines abstract primitive operations that concrete subclasses define to implement steps of an algorithm. implements a template method defining the skeleton of an algorithm. The template method calls primitive operations as well as operations defined in AbstractClass or those of other objects. ConcreteClass (MyApplication) implements the primitive operations to carry out subclass-specific steps of the algorithm. ","date":"2023-04-15","objectID":"/first_post/:8:1","tags":["Developments"],"title":"软件工程的复习——设计模式","uri":"/first_post/"},{"categories":["Software Engineering"],"content":"Key Points How to vary steps in template method subclass. 如何在模板方法子类中改变步骤： 模板方法是一种设计模式，它定义了一个算法的骨架，将具体实现留给子类来实现。在子类中，可以通过重写某些步骤来改变算法的具体实现，而不改变算法的整体结构。这种方式可以让模板方法更加灵活和可扩展，同时避免了代码重复的问题。 Understand the fragile base class problem and why object composition and interfaces are often a better alternative. 脆弱基类问题以及对象组合和接口为什么是更好的选择： 在模板方法中，子类必须依赖于抽象类的具体实现细节，这可能导致所谓的“脆弱基类”问题，即如果抽象类的实现发生变化，可能会导致子类的实现失效。 为了避免这种问题，可以使用对象组合和接口来代替继承和虚函数。对象组合可以允许对象在运行时动态组合，从而更加灵活和可扩展。接口可以定义对象之间的通信协议，从而解耦对象之间的具体实现细节。这两个技术通常被认为是更加健壮和灵活的设计模式，可以避免脆弱基类问题。 ","date":"2023-04-15","objectID":"/first_post/:8:2","tags":["Developments"],"title":"软件工程的复习——设计模式","uri":"/first_post/"},{"categories":["Software Engineering"],"content":"Observer ROS Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically. ","date":"2023-04-15","objectID":"/first_post/:9:0","tags":["Developments"],"title":"软件工程的复习——设计模式","uri":"/first_post/"},{"categories":["Software Engineering"],"content":"Structure Subject knows its observers. Any number of Observer objects may observe a subject.知道它的Observer。一个Subject可以有任意多个Observer。 provides an interface for attaching and detaching Observer objects. 提供删除/增加Observer的接口 Observer defines an updating interface for objects that should be notified of changes in a subject. Observer定义了一个更新接口，用于在Subject的状态发生变化时通知观察者。任何对象都可以成为Observer，只需实现Observer接口即可。 ConcreteSubject stores state of interest to ConcreteObserver objects. ConcreteSubject存储感兴趣的状态。 sends a notification to its observers when its state changes. 其状态发生变化时通知观察者。 ConcreteObserver maintains a reference to a ConcreteSubject object. ：ConcreteObserver维护对ConcreteSubject对象的引用 stores state that should stay consistent with the subject’s. 存储应该与主题保持一致的状态。 implements the Observer updating interface to keep its state consistent with the subject’s. 它实现了Observer接口中的更新方法，以便在Subject状态发生变化时更新自己的状态。 ","date":"2023-04-15","objectID":"/first_post/:9:1","tags":["Developments"],"title":"软件工程的复习——设计模式","uri":"/first_post/"},{"categories":["Software Engineering"],"content":"getting full update vs. selective registration and update. 完全更新 vs. 选择性注册和更新 ChatGPT says: 完全更新： 在完全更新变体中，主题在其状态发生变化时向观察者发送所有数据。这意味着观察者接收到主题数据的完整更新，即使只有一小部分数据发生了变化。这种方法实现简单，但如果主题数据很大或数据变化频繁，则效率可能较低。 选择性注册和更新： 在选择性注册和更新变体中，主题只向已注册接收该数据更新的观察者发送特定的数据。这意味着观察者只接收到他们感兴趣的数据的更新，而不是接收所有数据的完整更新。这种方法实现更复杂，但如果主题数据很大或数据变化频繁，则可能更有效。 ","date":"2023-04-15","objectID":"/first_post/:9:2","tags":["Developments"],"title":"软件工程的复习——设计模式","uri":"/first_post/"}]